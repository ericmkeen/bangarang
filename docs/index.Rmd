---
title: "`R` package `bangarang`"
output: html_document
author: Eric Keen Ezell
date: "2024-01-24"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

The `bangarang` package is a bundle of datasets and functions that help analysts with research in the Kitimat Fjord System (KFS) in the north coast of mainland British Columbia. Nearly all of the content is catered specifically to analysis of datasets from the *RV Bangarang* expedition of 2013 - 2015, which was focused on the abundance, distribution, and foraging ecology of whales, seabirds, salmon, and their prey during the months of summer and early fall. The research involved line-transect sampling, active acoustic (echosounder) surveys, and oceanographic sampling (both while underway and at a grid of stations).  

Methodological details can be found [here](https://www.proquest.com/openview/80b2657e67f175b980c671414383b11a/1?pq-origsite=gscholar&cbl=18750). More info on the *Bangarang* project can be found [here](https://rvbangarang.wordpress.com/). The *Bangarang* project was carried out as a doctoral thesis at Scripps Institution of Oceanography in close collaboration with the [Gitga'at First Nation](https://www.gitgaatnation.ca/oceans-lands), [BC Whales](www.bcwhales.org), Fisheries & Oceans Canada, and the NOAA Southwest Fisheries Science Center.  

### Installation

The `bangarang` package can be downloaded directly from `GitHub`:

```{r echo=TRUE, eval=FALSE}
# Install devtools if needed
if (!require('devtools')) install.packages('devtools')

# Increase timeout for download, since there are datasets
options(timeout=9999999)

# Install package
devtools::install_github('ericmkeen/bangarang')
```

Load into your `R` session:  

```{r echo=TRUE, eval=TRUE}
library(bangarang)
```

This vignette was made with `bangarang` version `r utils::packageVersion('LTabundR')`, and will make use of a few other packages: 

```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE}
library(tidyverse)
library(ggplot2)
```

### Maps

Produce a map of the *Bangarang* study area in the KFS using the `ggplot` and `sf` packages:  

```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE, fig.width = 6, fig.height=6}
gg_kfs()
```

As with all the `bangarang` functions, see this function's documentation for changing the geographic range, color, and transparency settings. 

```{r echo=TRUE, eval=FALSE, warning=FALSE, message=FALSE}
?gg_kfs
```


### Datasets

#### Land

```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE}
data(kfs_land)
```

```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE}
kfs_land %>% class

kfs_land %>% glimpse
```

Snapshot of dataset: 

```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE, fig.width = 4, fig.height=4}
par(mar=c(.1,.1,.1,.1))
kfs_land %>% plot
```

#### Seafloor 

```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE}
data(kfs_seafloor)

kfs_seafloor %>% glimpse
```

Plot it:  

```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE, fig.width = 6, fig.height=6}
ggplot(kfs_seafloor,
       aes(x=x, y=y, color=layer)) + 
  geom_point(size=.1) + 
  xlab(NULL) + ylab(NULL) + labs(color = 'Depth (m)') + 
  theme_minimal()
```

#### Proposed LNG shipping routes

```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE, fig.width = 6, fig.height=6}
data(shiplane)

shiplane %>% glimpse
```

Plot it:  

```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE, fig.width = 6, fig.height=6}
gg_kfs() + 
  geom_path(data=shiplane,
            mapping=aes(x=X, y=Y, group=PID)) + 
  xlab(NULL) + ylab(NULL)
```

#### Geostrata 

##### Four main "provinces" referenced in study

```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE}
data(provinces)

provinces %>% glimpse
```

Check it out:  

```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE, fig.width=6, fig.height=6}
gg_kfs() + 
  geom_polygon(data=provinces,
            mapping=aes(x=X, 
                        y=Y,
                        group = factor(province),
                        fill = factor(province),
                        color = factor(province)),
            alpha=.4) + 
  xlab(NULL) + ylab(NULL) + labs(fill='Province', color='Province')
```


##### Eight main channels referenced in study

```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE}
data(channels)

channels %>% glimpse
```

Check it out:  

```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE, fig.width=6, fig.height=6}
gg_kfs() + 
  geom_polygon(data=channels,
            mapping=aes(x=X, 
                        y=Y,
                        fill = province,
                        color = province),
            alpha=.4) + 
  xlab(NULL) + ylab(NULL)
```

##### Rectangular blocks (medium size). 

```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE}
data(kfs_blocks_bbox)

kfs_blocks_bbox %>% glimpse
```

Check it out:  

```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE, fig.width=6, fig.height=6}
gg_kfs() + 
  geom_rect(data=kfs_blocks_bbox,
            mapping=aes(xmin=left, 
                        xmax=right,
                        ymin=bottom,
                        ymax=top,
                        group=id),
            fill=NA,
            color='black') + 
  xlab(NULL) + ylab(NULL)
```

##### Rectangular blocks (small size). 

```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE}
data(blocks)

blocks %>% glimpse
```

Check it out:  

```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE, fig.width=6, fig.height=6}
gg_kfs() + 
  geom_rect(data=blocks,
            mapping=aes(xmin=left, 
                        xmax=right,
                        ymin=bottom,
                        ymax=top,
                        group=name),
            fill=NA,
            color='black') + 
  xlab(NULL) + ylab(NULL)
```


#### Oceanographic stations 

```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE}
data(stations)

stations %>% glimpse
```

Check it out:  

```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE, fig.width=6, fig.height=6}
gg_kfs() + 
  geom_point(data=stations,
            mapping=aes(x=long, 
                        y=lat,
                        group = block),
            alpha=.8) + 
  xlab(NULL) + ylab(NULL) + labs(group='Waterway')
```

#### Effort 

All survey effort aboard the *Bangarang*:  

```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE}
data(effort)

effort %>% glimpse
```

Map overview:  

```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE, fig.width=6, fig.height=6}
gg_kfs() + 
  geom_point(data=effort,
            mapping=aes(x=lon, 
                        y=lat,
                        color = effort),
            alpha=.4,
            size=.2) + 
  xlab(NULL) + ylab(NULL) 
```

Show each year separately: 

```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE, fig.width=6, fig.height=4}
gg_kfs() + 
  geom_point(data=effort,
            mapping=aes(x=lon, 
                        y=lat,
                        color = effort),
            alpha=.4,
            size=.2) + 
  facet_wrap(~lubridate::year(date)) + 
  xlab(NULL) + ylab(NULL) + 
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())
```

Show each circuit in 2015 separately, systematic transect effort only:  

```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE, fig.width=6, fig.height=6}
# Filter to transect effort only
transects <- 
  effort %>% 
  filter(lubridate::year(date) == 2015,
         effort == 'transect') %>% 
  mutate(group = paste0(lubridate::year(date), ' circuit ', circuit))

# plot it
gg_kfs() + 
  geom_point(data= transects,
             mapping=aes(x=lon, 
                        y=lat),
            alpha=.4,
            size=.2) + 
  facet_wrap(~group) + 
  xlab(NULL) + ylab(NULL) + 
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())
```

#### Seabirds 

```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE}
data(seabirds)

seabirds %>% glimpse
```

Map it: 

```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE, fig.width=8, fig.height=6}
gg_kfs() + 
  geom_point(data=seabirds,
            mapping=aes(x=lon, 
                        y=lat,
                        color = sp1,
                        size = best),
            alpha=.4) + 
  xlab(NULL) + ylab(NULL) 
```

Column definitions:  

- **`date`:** Date and time, in format `YYYY-MM-DD HH:MM:SS` .   

- **`lat`:**  Latitude in decimal degrees.   

- **`lon`:**  Longitude in decimal degrees.   

- **`effort`:**  Code for search effort: `"off"` = opportunistic sighting occurring while off search effort; `"casual"` = opportunistic sighting occurring while transiting area while off seaerch effort; `"station"` = opportunistic sighting while conducting sampling at oceanographic stations; `"with whale"` = opportunistic sighting while conducting focal follows of whales; `"transect"` = seabird detection during systematic line-transect effort. Analyses focused on density/abundance estimation should filter to `"transect"` effort only.  

- **`bft`:**  Beaufort sea state, ranging from `0` (glassy calm) to `4` (white caps everywhere); this may be a useful covariate in a density/abundance model.     

- **`precip`:** Precipitation state; another potentially useful covariate.  

- **`knots`:** Ship speed in knots.   

- **`hdg`:**  Ship heading (range = 0 - 360 degrees).  

- **`wind_kph_raw`:** Apparent wind speed, in kilometers per hour, as received by the shipboard weather station, unadjusted for ship speed or heading.  

- **`wind_hdg_raw`:** Apparent wind heading, in degrees, as received by the shipboard weather station, unadjusted for ship speed or heading.  

- **`zone`:** Category of distance from the vessel's track line, as estimated by a handheld rangefinder: Zone `"1"` is 0 - 75m, Zone `"2"` is 75m - 150m. The zone `"OUT"` means the bird was estimated to be beyond 150m. The zone `"221"` means that the bird was originally seen in Zone `2` but it approached as near as Zone 1 (either due to bird movement or ship approaching the bird). We recorded this note to test for a couple things: (1) If more birds are being observed in Zone 1 vs. Zone 2, that may mean that we are missing some birds in Zone 2 and our assumption that our strip width is 150m on either side of the vessel may be problematic; and (2) If more birds are being observed in Zone 2 than Zone 1, that may mean that birds are avoiding the vessel and some could even be flushing beyond Zone 2, which could also be problematic for density estimation. 

- **`line`:** An indication of whether there was uncertainty about which `zone` the bird occurred within; if `MIDL`, the bird occurred right on the line between Zone 1 and Zone 2 by the observer's estimation; if `OUTR`, the bird occurred right on the line between Zone 2 and beyond. If your analysis assumed a strip width of 150m on each side of the vessel, the sightings marked `OUTR` may be of special interest: how drastically would your density estimates change if those sightings were included or excluded?  

- **`side`:** The side of the vessel (`PORT` or `STARBOARD`) the bird was seen on. If the value is `HELM`, that means the researcher at the data entry position at the helm detected the sighting. Likely not relevant to basic density/abundance estimation analyses. 

- **`best`:** Best estimate of total flock size.  

- **`min`:** Minimum estimate of total flock size.   

- **`max`:** Maximum estimate of total flock size.  

- **`feed`:** Indication of whether or not the birds are feeding: `"M"` = Maybe; `"N"` = No; `"S"` = Some; `"W"` = Unknown; `"Y"` = Yes.  

- **`motion`:** Indication of bird's motion behavior: `"FLUSH"` = Birds were originally sitting but were flushed (either dove or flew off) in response to the research vessel; `"FLY"` = Birds were in flight; `"FOLO"` = Birds are following the research vessel (problematic for recounting!); `"RAFT"` = Birds were rafting on surface debris, such as floating kelp or logs; `"SIT"` = Birds were sitting on the water.  

- **`dir`:** Indication of bird's flight direction (if flying); cardinal directions are typically used (`"N"`, `"NE"`, `"E"`, `"SE"`, `"S"`, `"SW"`, `"W"`, `"NW"`) with the exception of birds circling the vessel (`"CIR"` or `"CR"`).  
  
- **`height`:** Estimate of bird's flight height above sea level, in meters. This is relevant because wind speed increases predictably with height above sea level.  

- **`sp1`:** Four-letter species code for primary (and possibly only) species in the flock.   

- **`per1`:** Percentage of total flock size that `sp1` comprises.  

- **`plum1`:** Primary plumage state for `sp1`. Note that, in some cases, if a single species occurs in several different plumage state, the same species might be entered as `sp1`, `sp2`, and even `sp3`. Codes: `"AB"` or `"ABE"` = Adult breeding, either/both sex(es); `"ABF"` = Adult breeding, female; `"ABM"` = Adult breeding, male; `"ANE"` = Adult non-breeding, either/both sex(es); `"FLE"` = Fledgling; `"JV"` or `"JVE"` = Juvenile; `"MX"` = Mixture of unspecified plumages present; `"NBE"` = Non-breeding, either/both sex(es); `"OTH"` = Other unspecified plumage; `"SA"` = Sub-adult plumage; `"AAE"` or `"AAM"` = unknown.  

- **`sp2`:** If this is a mixed-species flock with two or more species present, this is the four-letter species code for the second species.  

- **`per2`:** Percentage of total flock size that `sp2` comprises, if present.  

- **`plum2`:** Primary plumage state for `sp2`, if present.  

- **`sp3`:** If this is a mixed-species flock with three species present, this is the four-letter species code for the third species.  

- **`per3`:** Percentage of total flock size that `sp3` comprises, if present.  

- **`plum3`:** Primary plumage state for `sp3`, if present.  



#### Salmon 

```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE}
data(salmon)

salmon %>% glimpse
```

Map it;  

```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE, fig.width=6, fig.height=6}
gg_kfs() + 
  geom_point(data=salmon,
            mapping=aes(x=lon, 
                        y=lat,
                        size = jumps),
            alpha=.4) + 
  xlab(NULL) + ylab(NULL) 
```


```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE, fig.width=6, fig.height=4}
ggplot(salmon %>% 
         filter(zone < 3) %>% 
         mutate(Zone = factor(zone)),
       aes(x=Zone)) + 
  geom_bar(stat='count')

```

#### Whales 

```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE}
data(whale_sightings)

whale_sightings %>% glimpse
```

```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE, fig.width=6, fig.height=6}
gg_kfs() + 
  geom_point(data=whale_sightings,
            mapping=aes(x=x, 
                        y=y,
                        color = spp,
                        size = size),
            alpha=.4) + 
  xlab(NULL) + ylab(NULL) 
```

#### Oceanography 

This dataset is an interpolated grid of oceanographic values for each circuit in each year. Some variables are from the thermosalinograph we had running at the surface during transects, some are from the echosounder we used while underway, and others are from the Seabird Electronics CTD we used at the grid of oceanographic stations. 

```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE}
data(ocean)

ocean %>% glimpse
```

Here are the variables included:

```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE}
ocean$metric %>% unique %>% sort
```

As an example, say we wanted a map of the sea surface salinity (`SSS`) for each circuit of the 2015 season.  

```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE, fig.width=6, fig.height=6}
# Filter the dataset
sss <- 
  ocean %>% 
  filter(metric == 'SSS', 
         year==2015)

# Map it
gg_kfs() + 
  geom_point(data=sss,
             mapping=aes(x=lon, 
                         y=lat,
                         color=value),
             size=.05) + 
  facet_wrap(~circuit) +
  xlab(NULL) + ylab(NULL) + 
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank()) + 
  scale_color_gradientn(colours = rev(rainbow(5)))
```

### Helper functions

#### `in_block()`

A way to see which geostratum a pair of coordinates is located within. 

```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE}
in_block(x= -129.4, y=53.2)
```

```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE}
in_block(x= -129.2, y=52.9)
```
  
  
#### `in_kfs()`

A quick test to see if coordinates properly within the water within the boundaries of the KFS (as defined by the *Bangarang* project). The function returns the dataset with a new column, `inkfs`: 

```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE}
test <- in_kfs(seabirds %>% rename(x=lon, y=lat),
                 toplot = TRUE)

test$inkfs %>% table
```

  
  
#### `in_water()`

A quick test to see if coordinates properly within the water within the water (and not on land by mistake). The function returns the dataset with a new column, `valid`: 

```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE}
test <- in_water(seabirds %>% rename(x=lon, y=lat),
                 toplot = TRUE)

test$valid %>% table
```
  
  
  
#### `whale_map()`

Calculates the true position of a sighting within the KFS, in offshore or confined coastal waters, accounting for whether or not the observer is using the horizon or a shoreline as the basis for the reticle reading.  

The `X` and `Y` you supply is the observer's location (either a boat or a stationary field station).  

```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE}
whalemap(X= -129.2, 
         Y=52.9,
         bearing = 313,
         reticle = 0.2,
         eye.height = 2.1,
         vessel.hdg = 172,
         toplot=TRUE)
```

### Seabird density estimation

To showcase some other functions in the `bangarang` package, here is an example workflow for estimating the density/abundance of a seabird from the *Bangarang* study area. I use a density-surface-modeling (DSM) approach based on the `R` package `dsm` ([Github](https://github.com/DistanceDevelopment/dsm)). In a DSM, species density is estimated for each point in a grid of your study area. The `bangarang` package provides a 1-square-km grid as a built-in dataset: 

```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE}
data(grid, package='bangarang')
grid %>% head
```

Here is a map of the centroid of each grid cell:  

```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE}
gg_kfs() + 
  geom_point(data=grid, mapping=aes(x=x, y=y))
```

The package also offers a dataset of systematic transect effort split into 5-km segments, a common length in habitat modeling:  

```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE}
data(segments_5km)

# Rename
segments <- segments_5km

# Check out
segments %>% head

# View centroid of each segment
gg_kfs() + 
  geom_point(data=segments, mapping=aes(x=x, y=y), alpha=.5)
```


#### Sitting & flushed birds 

We then filter the built-in sightings dataset, `"seabirds"`, to our species of interest. In this case, marbled murrelet (4-letter code: "MAMU"). We will analyze sitting birds separately from flying birds, since the former will be relevant to subsequent foraging preference analyses. 

```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE}
data(seabirds)

mamu <-
  seabirds %>%
  filter(effort == 'transect') %>%
  filter(zone != 'OUT') %>%
  # filter to any sighting that had MAMU in any of the three species slots
  filter(sp1 == 'MAMU' | sp2 == 'MAMU' | sp3 == 'MAMU') %>%
  filter(motion %in% c('SIT', 'FLUSH')) %>%
  # provide a single authoritative species ID
  mutate(spp = 'MAMU')

# Check sample size
mamu %>% nrow

# Review data
mamu %>% as.data.frame %>% head

# Map data
gg_kfs() + 
  geom_point(data=mamu, mapping=aes(x=lon, y=lat, size=best), alpha=.5)
```

We now need to determine which effort segment each sighting occurred during. To do so, use the function `segment_sync()`, which uses time differences to find the segment that overlaps with each sighting's timestamp:  

```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE}
# Sync segment numbers to sightings
mamu <- segment_sync(segments = segments,
                     sightings = mamu)
```

We then use the `format_observation_data()` function to transform the `mamu` dataset to meet formatting requirements for the DSM:

```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE}
observation_data <- format_observation_data(mamu)

observation_data %>% as.data.frame %>% head
```

Since we used strip-width sampling in seabird surveys aboard the *Bangarang*, we will create a dummy detection function that stands in for this aspect of the DSM analysis:  

```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE}
dummy_ds <- create_dummy_detection_function(observation_data)
```

We can now develop our DSM using the function `dsm()` from package `dsm`.  Here is a basic example that models density according to a spline interaction of longitude and latitude. (The `convert.units` input handles the fact that, in our `seabirds` dataset, distance is specified in meters instead of kilometers.). 

```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE}
library(dsm)

dsm_basic <-
  dsm(formula = density.est ~ s(x,y),
      ddf.obj = dummy_ds,
      convert.units=1/1000,
      segment.data = segments,
      observation.data = observation_data)
```

Here is a summary of that model:  

```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE}
dsm_basic %>% summary
```

We then use that DSM to predict murrelet density on our spatial grid:

```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE}
d <- predict_dsm_kfs(dsm_basic, segments, grid)
```

That function, `predict_dsm_kfs()`, returns a vector of density estimates (birds km^-2) equal in length to the number of rows in the `grid` `data.frame`.  

```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE}
d %>% hist
```

You can also use a wrapper function, `predict_circuits()`, to predict the density surface during each circuit of the study area. We completed a total of 9 circuits whose information is contained in the built-in dataset `data(circuits)`:  

```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE}
data(circuits)

circuits %>% head

d_circuits <- 
  predict_circuits(dsm_basic, 
                   segments,
                   grid,
                   toplot=FALSE)
```

We can use the function `point_summary()` to calculate average density across the DSM: 

```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE}
point_summary(d_circuits)
```

##### Model selection

To improve the DSM model, you can introduce covariates from your `segments` dataset.  The `bangarang` package provides a function, `dsm_comps()`, that will ues AICc to rank candidate models for all possible combinations of the supplied covariates. The analyst can then decide which formula to bring into the density estimation stage. The assumed distribution family is `"tweedie"`.    

```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE}
dsm_comps <- 
  dsm_compare(segments,
              observation_data,
              dummy_ds,
              candidate_splines = c('s(yday)', 's(z)', 'year'),
              base_formula = 'density.est ~ s(x,y)')
```

That process produces the following summary: 

```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE}
dsm_comps$dsm
```

Based on this summary, we can get details on the most parsimonious model:  

```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE}
dsm_comps$objects[[7]] %>% summary
```

And we will save that model object as our model to keep: 

```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE}
dsm_keep <- dsm_comps$objects[[7]]
```

And we will re-run our point estimate using that model:  

```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE}
point_estimate <-
  predict_circuits(dsm_keep, segments, grid, toplot=FALSE)

point_summary(point_estimate)
```

##### Variance estimation

To quantify the uncertainty in our point estimate, the `bangarang` package provides a bootstrap function.  

First, we store the formula used in the best-fit DSM:  

```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE}
(dsm_formula <- summary(dsm_keep)$formula)
```

Next, we can use the function `bootstrapper_wrapper()` to repeat the circuit density prediction routine with iteratively resampled versions of the segments and sightings data:  


```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE}
bootstraps <-
  bootstrapper_wrapper(dsm_formula,
                       segments,
                       observation_data,
                       grid,
                       group_draw = FALSE,
                       on_the_line = FALSE,
                       B = 5,
                       output_filename = NULL)
```

(See the documentation for that function for more help.)  

Take a look at the result ... 

```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE}
bootstraps %>% as.data.frame %>% head
```

... which can be summarized using the function `bootstrapper_summary()`:

```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE}
bootstrapper_summary(bootstraps)
```

That bootstrap result can be combined with the point estimates as follows: 

```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE}
result <- 
  left_join(point_summary(point_estimate) %>% select(-dsd),
          (bootstrapper_summary(bootstraps) %>% select(circuit_name, SD, L95, U95)),
          by='circuit_name') %>% 
  mutate(CV = SD / dmean)

result
```

This result can be plotted as follows: 

```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE}
ggplot(result %>% 
         mutate(circuit_name = factor(circuit_name, levels=circuit_name)),
       aes(x=circuit_name,
           y=dmean,
           ymin=L95,
           ymax=U95)) + 
  geom_errorbar(width=.1) + 
  geom_point() +
  xlab(NULL) + 
  ylab('Density') + 
  theme_light()
```


#### Flying birds

Flying birds pose special challenges (see Spear & Ainley 1997). In order to account for the bias caused by the possibliity of repeat-counting a flying bird, we need to perform corrections that rely upon ship speed and direction; bird speed, direction and flight height; and published regressions that predict bird speed for different seabird groups at certain orientations to the wind and at certain heights above the water. 

So first we get the flying murrelets in our dataset:  

```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE}
data(seabirds)

mamu <-
  seabirds %>%
  filter(effort == 'transect') %>%
  filter(zone != 'OUT') %>%
  filter(sp1 == 'MAMU' | sp2 == 'MAMU' | sp3 == 'MAMU') %>%
  filter(motion %in% c('FLY')) %>%
  mutate(spp = 'MAMU')

# Sample size
mamu %>% nrow
```

To account for the biases introduced by flying bird "flux", we bring in a built-in dataset that contains flight-wind regression data from Spear & Ainley (1997): 

```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE}
data(flight_groups)

flight_groups %>% head
```

We then use that regression data in the function `calculate_flight_flux()`, which scales group size by the flux correction factor (see that function's documentation for details):  

```{r echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE}
# Mean group size before flux correction
mamu$best %>% mean(na.rm=TRUE)

# Calculate flux correction
mamu <- calculate_flight_flux(mamu, flight_groups)

# Apply to group estimates
mamu <- 
  mamu %>% mutate(best = best * correction_factor,
                  min = min * correction_factor,
                  max = max * correction_factor)
                  
# Mean after
mamu$best %>% mean(na.rm=TRUE)
```

Now that flux is accounted for, you can proceed using the same method for sitting birds above. 

Total murrelet density will be the sum of sitting and flying birds.  

